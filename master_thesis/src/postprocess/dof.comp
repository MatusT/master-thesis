#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
  vec2 size;
  vec2 autofocusPoint;

  float dof;
  float focus;

  float amount;
};

layout(set = 0, binding = 0) uniform sampler linear_sampler;

layout(set = 0, binding = 1) uniform texture2D color_texture;
layout(set = 0, binding = 2) uniform texture2D depth_texture;

layout(set = 0, binding = 3, rgba8) uniform writeonly image2D output_texture;

uint wang_hash(uint seed) {
  seed = (seed ^ 61) ^ (seed >> 16);
  seed *= 9;
  seed = seed ^ (seed >> 4);
  seed *= 0x27d4eb2d;
  seed = seed ^ (seed >> 15);
  return seed;
}

float rand(uint value) {
  return float(wang_hash(value)) * (1.0 / 4294967296.0);
}

void main(void) {

  // vec2 autofocusPoint = vec2(0.37, 0.5);
  vec2 _autofocusPoint = vec2(0.5, 0.5);
  float autofocus = 1.0;

  float dp = 0.99;

  vec2 texCoord = vec2(gl_GlobalInvocationID.xy) / size;

  vec4 _color4 = texture(sampler2D(color_texture, linear_sampler), texCoord);
  vec4 _depth4 = texture(sampler2D(depth_texture, linear_sampler), texCoord);


 {
  float d = _depth4.r * 100.0;


  imageStore(
      output_texture, ivec2(gl_GlobalInvocationID.xy),
      vec4(_color4)
      );

      return;
}





  // if (_depth4.r > 0.9939)
  //   gl_FragColor = vec4(1);
  // else
  //   gl_FragColor = vec4(0);

  // if (false)
  //   if (length(texCoord - autofocusPoint) < 0.005) {
  //     if (length(texCoord - autofocusPoint) < 0.003) {
  //       gl_FragColor = vec4(1, 1, 1, 1) * autofocus;
  //     } else {
  //       gl_FragColor = vec4(0, 0, 0, 1);
  //     }
  //     return;
  //   }

  vec4 samFocus =
      texture(sampler2D(depth_texture, linear_sampler), _autofocusPoint);

  float _focus = samFocus.r; 0.0;//mix(focus, samFocus.r, autofocus);
  float _dof = 0.028;
  float _depth = _depth4.r;
  float _coc = 0.0;

  // if (_depth == 1) {
  //   _coc = 0.5;
  // } else if (abs(_depth - _focus) < _dof) {
  //   _coc = abs(_depth - _focus) / _dof;
  // } else {
  //   _coc = 1.0;
  // }
  if (_depth4.r == 1.0) {
    _coc = 0.5;
  } else if (abs(_depth - _focus) < _dof) {
    _coc = abs(_depth - _focus) / _dof;
  } else {
    _coc = 0.0;
  }

  float _amount = 1.0;
  vec2 offset = vec2(0, 0);

  // average depth difference
  float samDD;
  float maxDD = 0.0;
  float accumDD = 0.0;
  float sumDD = 0.0;
  for (uint i = 0; i < 1; i++) {
    // vec2 rv = (-1.0 + 2.0 * vec2(rand(81*i+0), rand(81*i+13)));
    float a = rand(81 * i + 0) * 2.0 * 3.141592654;
    float r = sqrt(rand(81 * i + 13));
    vec2 rv = vec2(r * cos(a), r * sin(a));

    offset = rv * 0.01 * _amount * 0.5;

    vec4 samDD4 =
        texture(sampler2D(color_texture, linear_sampler), texCoord + offset);

    samDD = // abs
        (_depth - samDD4.r);

    // remove halos around outer contours
    if (_depth == 0.0)
      samDD = 0.0;

    accumDD += samDD;
    sumDD++;
  }
  accumDD /= sumDD;

  vec4 sam;
  vec3 accum = vec3(0.0);
  float accumA = 0.0;

  float sum = 0.0;
  float sumA = 0.0;

_coc = 0.0;

  for (uint i = 0; i < 1; i++) {
    // vec2 rv = (-1.0 + 2.0 * vec2(rand(81*i+0), rand(81*i+13)));
    float a = rand(81 * i + 0) * 2.0 * 3.141592654;
    float r = sqrt(rand(81 * i + 13));

    vec2 rv = vec2(r * cos(a), r * sin(a));
    // rv = normalize(rv);

    offset = rv * 0.01 * (_coc + accumDD) * 2.0;

    sam = texture(sampler2D(color_texture, linear_sampler), texCoord + offset);

    // if (sam.a == 0) sam.rgb = vec3(1.0,0.0,0.0);

    accum += sam.rgb * sam.a;
    sum += sam.a;

    accumA += sam.a;
    sumA++;
  }
  accum /= sum;
  accumA /= sumA;

  float fog = clamp(_depth - _focus, 0.0, 1.0) / _dof;
  fog = clamp(pow(fog * 25.0, 4.0), 0.0, 1.0);

  imageStore(
      output_texture, ivec2(gl_GlobalInvocationID.xy),
      // vec4(mix(vec3(accum), vec3(0.02, 0.04, 0.05), fog), pow(accumA, 1.0)));
      vec4(mix(vec3(accum), vec3(0.02, 0.04, 0.05), 0.0), 1.0));
      //vec4(vec3(clamp(_coc * 100.0, 0.0, 1.0)), 1.0));

}
